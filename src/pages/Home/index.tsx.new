import React, { useEffect, useState } from 'react';
import { HomeContainer, WeatherCardsList, WeatherCard, WeatherIcon, WeatherInfo } from './styled';
import * as WeatherIcons from 'react-icons/wi';

interface WeatherItem {
  dt: number;
  dt_txt: string;
  main: {
    temp: number;
  };
  weather: {
    id: number;
    main: string;
    description: string;
    icon: string;
  }[];
}

interface WeatherData {
  city?: {
    name: string;
  };
  list: WeatherItem[];
}

const Home: React.FC = () => {
  const [location, setLocation] = useState<{ lat: number; lon: number } | null>(null);
  const [weather, setWeather] = useState<WeatherData | null>(null);
  const [error, setError] = useState<string | null>(null);
  
  // Função para determinar qual ícone exibir baseado no ID do tempo
  const getWeatherIcon = (weatherId: number, icon: string): JSX.Element => {
    // Verifica se é dia ou noite pelo código do ícone
    const isNight = icon.includes('n');
    
    // Função para renderizar um componente de ícone do clima dinamicamente
    const renderWeatherIcon = (iconName: string) => {
      const IconComponent = WeatherIcons[iconName as keyof typeof WeatherIcons];
      return IconComponent ? React.createElement(IconComponent, { size: 42 }) : null;
    };
    
    // Com base no ID e se é dia ou noite
    if (weatherId >= 200 && weatherId < 300) {
      return renderWeatherIcon('WiThunderstorm');
    } else if (weatherId >= 300 && weatherId < 400) {
      return renderWeatherIcon('WiShowers');
    } else if (weatherId >= 500 && weatherId < 600) {
      return renderWeatherIcon('WiRain');
    } else if (weatherId >= 600 && weatherId < 700) {
      return renderWeatherIcon('WiSnow');
    } else if (weatherId >= 700 && weatherId < 800) {
      return renderWeatherIcon('WiFog');
    } else if (weatherId === 800) {
      return isNight ? renderWeatherIcon('WiNightClear') : renderWeatherIcon('WiDaySunny');
    } else if (weatherId === 801) {
      return isNight ? renderWeatherIcon('WiNightCloudy') : renderWeatherIcon('WiDayCloudy');
    } else if (weatherId > 801 && weatherId < 900) {
      return renderWeatherIcon('WiCloudy');
    } else {
      return renderWeatherIcon('WiCloud');
    }
  };

  const getLocationFromIP = async () => {
    try {
      const res = await fetch('https://ipapi.co/json/');
      const data = await res.json();
      if (data.latitude && data.longitude) {
        setLocation({ lat: data.latitude, lon: data.longitude });
      } else {
        setError('Não foi possível obter localização via IP.');
      }
    } catch {
      setError('Erro ao consultar localização aproximada via IP.');
    }
  };

  useEffect(() => {
    if (!navigator.geolocation) {
      getLocationFromIP();
      return;
    }

    navigator.geolocation.getCurrentPosition(
      position => {
        setLocation({
          lat: position.coords.latitude,
          lon: position.coords.longitude,
        });
      },
      err => {
        console.warn('Erro GPS:', err.message);
        getLocationFromIP();
      }
    );
  }, []);

  useEffect(() => {
    if (location) {
      const fetchWeather = async () => {
        try {
          const res = await fetch(
            `https://api.openweathermap.org/data/2.5/forecast?lat=${location.lat}&lon=${location.lon}&appid=d4a49eacfa033a8d61f972cf1b0df6e1&units=metric&lang=pt_br`
          );
          const data = await res.json();
          setWeather(data);
        } catch {
          setError('Erro ao buscar previsão do tempo.');
        }
      };
      fetchWeather();
    }
  }, [location]);

  return (
    <HomeContainer>
      <h1>Previsão do Tempo</h1>

      {error && <p style={{ color: 'red' }}>{error}</p>}

      {!location && !error && <p>Detectando localização...</p>}

      {weather && weather.city && (
        <>
          <p>
            Previsão para: <strong>{weather.city.name}</strong>
          </p>
          
          <WeatherCardsList>
            {weather.list
              .filter((item: WeatherItem) => item.dt_txt.includes('12:00:00'))
              .map((item: WeatherItem) => (
                <WeatherCard key={item.dt}>
                  <WeatherIcon>
                    {getWeatherIcon(item.weather[0].id, item.weather[0].icon)}
                  </WeatherIcon>
                  <WeatherInfo>
                    <div className="day">
                      {new Date(item.dt_txt).toLocaleDateString('pt-BR', {
                        weekday: 'long',
                        day: '2-digit',
                        month: '2-digit',
                      })}
                    </div>
                    <div className="description">
                      <span className="temp">{Math.round(item.main.temp)}°C</span>
                      <span className="condition">{item.weather[0].description}</span>
                    </div>
                  </WeatherInfo>
                </WeatherCard>
              ))}
          </WeatherCardsList>
        </>
      )}
    </HomeContainer>
  );
};

export default Home;
